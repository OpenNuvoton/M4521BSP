<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M4521 BSP: UART_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="m4.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">M4521 BSP
   &#160;<span id="projectnumber">V3.00.001</span>
   </div>
   <div id="projectbrief">The Board Support Package for M4521 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">UART_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_m4521_8h_source.html">M4521.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a02b6f92555f0223a7cf1b7f28d62a63f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a02b6f92555f0223a7cf1b7f28d62a63f">DAT</a></td></tr>
<tr class="separator:a02b6f92555f0223a7cf1b7f28d62a63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf055aeb3159102df9c35e5fc62359c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a0cf055aeb3159102df9c35e5fc62359c">INTEN</a></td></tr>
<tr class="separator:a0cf055aeb3159102df9c35e5fc62359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de833089a87f96f64fe1eb2e96ac893"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a9de833089a87f96f64fe1eb2e96ac893">FIFO</a></td></tr>
<tr class="separator:a9de833089a87f96f64fe1eb2e96ac893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabb58cc2e95cfafa6b62518953d37aa"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#afabb58cc2e95cfafa6b62518953d37aa">LINE</a></td></tr>
<tr class="separator:afabb58cc2e95cfafa6b62518953d37aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38873ff3f8930d902c756500ec1eb4a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#aa38873ff3f8930d902c756500ec1eb4a">MODEM</a></td></tr>
<tr class="separator:aa38873ff3f8930d902c756500ec1eb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa690036996b10aec30c30f25f68692e6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#aa690036996b10aec30c30f25f68692e6">MODEMSTS</a></td></tr>
<tr class="separator:aa690036996b10aec30c30f25f68692e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e343a39888f896bb89cb13a6cd56e6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a13e343a39888f896bb89cb13a6cd56e6">FIFOSTS</a></td></tr>
<tr class="separator:a13e343a39888f896bb89cb13a6cd56e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada15f66e56e66795932cb68174048260"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#ada15f66e56e66795932cb68174048260">INTSTS</a></td></tr>
<tr class="separator:ada15f66e56e66795932cb68174048260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccaf08eb25ede5ba592d720ef865d93"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#abccaf08eb25ede5ba592d720ef865d93">TOUT</a></td></tr>
<tr class="separator:abccaf08eb25ede5ba592d720ef865d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60210f63317de5a3432d775dbc4c9209"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a60210f63317de5a3432d775dbc4c9209">BAUD</a></td></tr>
<tr class="separator:a60210f63317de5a3432d775dbc4c9209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01ae1a9bbaa02f54a6e7cc944450b62"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#ac01ae1a9bbaa02f54a6e7cc944450b62">IRDA</a></td></tr>
<tr class="separator:ac01ae1a9bbaa02f54a6e7cc944450b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252c7acfa6d3c8de8524c72fc78d76f1"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a252c7acfa6d3c8de8524c72fc78d76f1">ALTCTL</a></td></tr>
<tr class="separator:a252c7acfa6d3c8de8524c72fc78d76f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1259d698217673bdf587e52f022961"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a5f1259d698217673bdf587e52f022961">FUNCSEL</a></td></tr>
<tr class="separator:a5f1259d698217673bdf587e52f022961"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
Memory Mapped Structure for UART Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l19228">19228</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a252c7acfa6d3c8de8524c72fc78d76f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252c7acfa6d3c8de8524c72fc78d76f1">&#9670;&nbsp;</a></span>ALTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::ALTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ALTCTL
</font><br><p> <font size="2">
Offset: 0x2C  UART Alternate Control/Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>BRKFL</td><td><div style="word-wrap: break-word;"><b>UART LIN Break Field Length (Only Available In UART0/UART1 Channel)
</b><br>
This field indicates a 4-bit LIN TX break field count.
<br>
Note1: This break field length is BRKFL + 1
<br>
Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
<br>
</div></td></tr><tr><td>
[6]</td><td>LINRXEN</td><td><div style="word-wrap: break-word;"><b>LIN RX Enable Bit (Only Available In UART0/UART1 Channel)
</b><br>
0 = LIN RX mode Disabled.
<br>
1 = LIN RX mode Enabled.
<br>
</div></td></tr><tr><td>
[7]</td><td>LINTXEN</td><td><div style="word-wrap: break-word;"><b>LIN TX Break Mode Enable Bit (Only Available In UART0/UART1 Channel)
</b><br>
0 = LIN TX Break mode Disabled.
<br>
1 = LIN TX Break mode Enabled.
<br>
Note: When TX break field transfer operation finished, this bit will be cleared automatically.
<br>
</div></td></tr><tr><td>
[8]</td><td>RS485NMM</td><td><div style="word-wrap: break-word;"><b>RS-485 Normal Multi-Drop Operation Mode (NMM)
</b><br>
0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
<br>
1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
<br>
Note: It cannot be active with RS-485_AAD operation mode.
<br>
</div></td></tr><tr><td>
[9]</td><td>RS485AAD</td><td><div style="word-wrap: break-word;"><b>RS-485 Auto Address Detection Operation Mode (AAD)
</b><br>
0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
<br>
1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
<br>
Note: It cannot be active with RS-485_NMM operation mode.
<br>
</div></td></tr><tr><td>
[10]</td><td>RS485AUD</td><td><div style="word-wrap: break-word;"><b>RS-485 Auto Direction Function (AUD)
</b><br>
0 = RS-485 Auto Direction Operation function (AUD) Disabled.
<br>
1 = RS-485 Auto Direction Operation function (AUD) Enabled.
<br>
Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
<br>
</div></td></tr><tr><td>
[15]</td><td>ADDRDEN</td><td><div style="word-wrap: break-word;"><b>RS-485 Address Detection Enable Bit
</b><br>
This bit is used to enable RS-485 Address Detection mode.
<br>
0 = Address detection mode Disabled.
<br>
1 = Address detection mode Enabled.
<br>
Note: This bit is used for RS-485 any operation mode.
<br>
</div></td></tr><tr><td>
[17]</td><td>ABRIF</td><td><div style="word-wrap: break-word;"><b>Auto-Baud Rate Interrupt Flag (Read Only)
</b><br>
This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_INTEN [18]) is set then the auto-baud rate interrupt will be generated.
<br>
Note: This bit is read only, but it can be cleared by writing "1" to ABRDTOIF (UART_FIFOSTS[2]) and ABRDIF(UART_FIFOSTS[1])
<br>
</div></td></tr><tr><td>
[18]</td><td>ABRDEN</td><td><div style="word-wrap: break-word;"><b>Auto-Baud Rate Detect Enable Bit
</b><br>
0 = Auto-baud rate detect function Disabled.
<br>
1 = Auto-baud rate detect function Enabled.
<br>
This bit is cleared automatically after auto-baud detection is finished.
<br>
</div></td></tr><tr><td>
[20:19]</td><td>ABRDBITS</td><td><div style="word-wrap: break-word;"><b>Auto-Baud Rate Detect Bit Length
</b><br>
00 = 1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01.
<br>
01 = 2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02.
<br>
10 = 4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08.
<br>
11 = 8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80.
<br>
Note : The calculation of bit number includes the START bit.
<br>
</div></td></tr><tr><td>
[31:24]</td><td>ADDRMV</td><td><div style="word-wrap: break-word;"><b>Address Match Value
</b><br>
This field contains the RS-485 address match values.
<br>
Note: This field is used for RS-485 auto address detection mode.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20408">20408</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="a60210f63317de5a3432d775dbc4c9209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60210f63317de5a3432d775dbc4c9209">&#9670;&nbsp;</a></span>BAUD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::BAUD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">BAUD
</font><br><p> <font size="2">
Offset: 0x24  UART Baud Rate Divisor Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>BRD</td><td><div style="word-wrap: break-word;"><b>Baud Rate Divider
</b><br>
The field indicates the baud rate divider.
<br>
This filed is used in baud rate calculation.
<br>
The detail description is shown in Table 6.21-2.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>EDIVM1</td><td><div style="word-wrap: break-word;"><b>Extra Divider For BAUD Rate Mode 1
</b><br>
This field is used for baud rate calculation in mode 1 and has no effect for baud rate calculation in mode 0 and mode 2.
<br>
The detail description is shown in Table 6.21-2.
<br>
</div></td></tr><tr><td>
[28]</td><td>BAUDM0</td><td><div style="word-wrap: break-word;"><b>BAUD Rate Mode Selection Bit 0
</b><br>
This bit is baud rate mode selection bit 0.
<br>
UART provides three baud rate calculation modes.
<br>
This bit combines with BAUDM1 (UART_BAUD[29]) to select baud rate calculation mode.
<br>
The detail description is shown in Table 6.21-2.
<br>
</div></td></tr><tr><td>
[29]</td><td>BAUDM1</td><td><div style="word-wrap: break-word;"><b>BAUD Rate Mode Selection Bit 1
</b><br>
This bit is baud rate mode selection bit 1.
<br>
UART provides three baud rate calculation modes.
<br>
This bit combines with BAUDM0 (UART_BAUD[28]) to select baud rate calculation mode.
<br>
The detail description is shown in Table 6.21-2.
<br>
Note: In IrDA mode must be operated in mode 0.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20406">20406</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="a02b6f92555f0223a7cf1b7f28d62a63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b6f92555f0223a7cf1b7f28d62a63f">&#9670;&nbsp;</a></span>DAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::DAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DAT
</font><br><p> <font size="2">
Offset: 0x00  UART Receive/Transmit Buffer Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>DAT</td><td><div style="word-wrap: break-word;"><b>Receiving/Transmit Buffer
</b><br>
Write Operation:
<br>
By writing one byte to this register, the data byte will be stored in transmitter FIFO.
<br>
The UART Controller will send out the data stored in transmitter FIFO top location through the UART_TXD.
<br>
Read Operation:
<br>
By reading this register, the UART will return an 8-bit data received from receiving FIFO.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20397">20397</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="a9de833089a87f96f64fe1eb2e96ac893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de833089a87f96f64fe1eb2e96ac893">&#9670;&nbsp;</a></span>FIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::FIFO</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FIFO
</font><br><p> <font size="2">
Offset: 0x08  UART FIFO Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>RXRST</td><td><div style="word-wrap: break-word;"><b>RX Field Software Reset
</b><br>
When RXRST (UART_FIFO[1]) is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
<br>
0 = No effect.
<br>
1 = Reset the RX internal state machine and pointers.
<br>
Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
<br>
</div></td></tr><tr><td>
[2]</td><td>TXRST</td><td><div style="word-wrap: break-word;"><b>TX Field Software Reset
</b><br>
When TXRST (UART_FIFO[2]) is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
<br>
0 = No effect.
<br>
1 = Reset the TX internal state machine and pointers.
<br>
Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
<br>
</div></td></tr><tr><td>
[7:4]</td><td>RFITL</td><td><div style="word-wrap: break-word;"><b>RX FIFO Interrupt Trigger Level
</b><br>
When the number of bytes in the receive FIFO equals the RFITL, the RDAIF will be set (if RDAIEN (UART_INTEN [0]) enabled, and an interrupt will be generated).
<br>
0000 = RX FIFO Interrupt Trigger Level is 1 byte.
<br>
0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
<br>
0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
<br>
0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
<br>
Others = Reserved.
<br>
</div></td></tr><tr><td>
[8]</td><td>RXOFF</td><td><div style="word-wrap: break-word;"><b>Receiver Disable
</b><br>
The receiver is disabled or not (set 1 to disable receiver)
<br>
0 = Receiver Enabled.
<br>
1 = Receiver Disabled.
<br>
Note: This bit is used for RS-485 Normal Multi-drop mode.
<br>
It should be programmed before RS485NMM (UART_ALTCTL [8]) is programmed.
<br>
</div></td></tr><tr><td>
[19:16]</td><td>RTSTRGLV</td><td><div style="word-wrap: break-word;"><b>nRTS Trigger Level For Auto-Flow Control Use
</b><br>
0000 = nRTS Trigger Level is 1 bytes.
<br>
0001 = nRTS Trigger Level is 4bytes.
<br>
0010 = nRTS Trigger Level is 8 bytes.
<br>
0011 = nRTS Trigger Level is 14 bytes.
<br>
Others = Reserved.
<br>
Note: This field is used for auto nRTS flow control.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20399">20399</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="a13e343a39888f896bb89cb13a6cd56e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e343a39888f896bb89cb13a6cd56e6">&#9670;&nbsp;</a></span>FIFOSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::FIFOSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FIFOSTS
</font><br><p> <font size="2">
Offset: 0x18  UART FIFO Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RXOVIF</td><td><div style="word-wrap: break-word;"><b>RX Overflow Error Interrupt Flag (Read Only)
</b><br>
This bit is set when RX FIFO overflow.
<br>
If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size, 16 bytes this bit will be set.
<br>
0 = RX FIFO is not overflow.
<br>
1 = RX FIFO is overflow.
<br>
Note: This bit is read only, but can be cleared by writing "1" to it.
<br>
</div></td></tr><tr><td>
[1]</td><td>ABRDIF</td><td><div style="word-wrap: break-word;"><b>Auto-Baud Rate Detect Interrupt (Read Only)
</b><br>
0 = Auto-baud rate detect function is not finished.
<br>
1 = Auto-baud rate detect function is finished.
<br>
This bit is set to logic "1" when auto-baud rate detect function is finished.
<br>
Note: This bit is read only, but can be cleared by writing "1" to it.
<br>
</div></td></tr><tr><td>
[2]</td><td>ABRDTOIF</td><td><div style="word-wrap: break-word;"><b>Auto-Baud Rate Time-Out Interrupt (Read Only)
</b><br>
0 = Auto-baud rate counter is underflow.
<br>
1 = Auto-baud rate counter is overflow.
<br>
Note1: This bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.
<br>
Note2: This bit is read only, but can be cleared by writing "1" to it.
<br>
</div></td></tr><tr><td>
[3]</td><td>ADDRDETF</td><td><div style="word-wrap: break-word;"><b>RS-485 Address Byte Detect Flag (Read Only)
</b><br>
0 = Receiver detects a data that is not an address bit (bit 9 ='0').
<br>
1 = Receiver detects a data that is an address bit (bit 9 ='1').
<br>
Note1: This field is used for RS-485 function mode and ADDRDEN (UART_ALTCTL[15]) is set to 1 to enable Address detection mode .
<br>
Note2: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[4]</td><td>PEF</td><td><div style="word-wrap: break-word;"><b>Parity Error Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received character does not have a valid "parity bit".
<br>
0 = No parity error is generated.
<br>
1 = Parity error is generated.
<br>
Note: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[5]</td><td>FEF</td><td><div style="word-wrap: break-word;"><b>Framing Error Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
<br>
0 = No framing error is generated.
<br>
1 = Framing error is generated.
<br>
Note: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[6]</td><td>BIF</td><td><div style="word-wrap: break-word;"><b>Break Interrupt Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received data input (RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).
<br>
0 = No Break interrupt is generated.
<br>
1 = Break interrupt is generated.
<br>
Note: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[13:8]</td><td>RXPTR</td><td><div style="word-wrap: break-word;"><b>RX FIFO Pointer (Read Only)
</b><br>
This field indicates the RX FIFO Buffer Pointer.
<br>
When UART receives one byte from external device, RXPTR increases one.
<br>
When one byte of RX FIFO is read by CPU, RXPTR decreases one.
<br>
The Maximum value shown in RXPTR is 15.
<br>
When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0.
<br>
As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 15.
<br>
</div></td></tr><tr><td>
[14]</td><td>RXEMPTY</td><td><div style="word-wrap: break-word;"><b>Receiver FIFO Empty (Read Only)
</b><br>
This bit initiate RX FIFO empty or not.
<br>
0 = RX FIFO is not empty.
<br>
1 = RX FIFO is empty.
<br>
Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.
<br>
It will be cleared when UART receives any new data.
<br>
</div></td></tr><tr><td>
[15]</td><td>RXFULL</td><td><div style="word-wrap: break-word;"><b>Receiver FIFO Full (Read Only)
</b><br>
This bit initiates RX FIFO full or not.
<br>
0 = RX FIFO is not full.
<br>
1 = RX FIFO is full.
<br>
Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
<br>
</div></td></tr><tr><td>
[21:16]</td><td>TXPTR</td><td><div style="word-wrap: break-word;"><b>TX FIFO Pointer (Read Only)
</b><br>
This field indicates the TX FIFO Buffer Pointer.
<br>
When CPU writes one byte into UART_DAT, TXPTR increases one.
<br>
When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases one.
<br>
The Maximum value shown in TXPTR is 15.
<br>
When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0.
<br>
As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 15.
<br>
</div></td></tr><tr><td>
[22]</td><td>TXEMPTY</td><td><div style="word-wrap: break-word;"><b>Transmitter FIFO Empty (Read Only)
</b><br>
This bit indicates TX FIFO empty or not.
<br>
0 = TX FIFO is not empty.
<br>
1 = TX FIFO is empty.
<br>
Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
<br>
It will be cleared when writing data into DAT (TX FIFO not empty).
<br>
</div></td></tr><tr><td>
[23]</td><td>TXFULL</td><td><div style="word-wrap: break-word;"><b>Transmitter FIFO Full (Read Only)
</b><br>
This bit indicates TX FIFO full or not.
<br>
0 = TX FIFO is not full.
<br>
1 = TX FIFO is full.
<br>
Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
<br>
</div></td></tr><tr><td>
[24]</td><td>TXOVIF</td><td><div style="word-wrap: break-word;"><b>TX Overflow Error Interrupt Flag (Read Only)
</b><br>
If TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to logic 1.
<br>
0 = TX FIFO is not overflow.
<br>
1 = TX FIFO is overflow.
<br>
Note: This bit is read only, but can be cleared by writing "1" to it.
<br>
</div></td></tr><tr><td>
[28]</td><td>TXEMPTYF</td><td><div style="word-wrap: break-word;"><b>Transmitter Empty Flag (Read Only)
</b><br>
This bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.
<br>
0 = TX FIFO is not empty.
<br>
1 = TX FIFO is empty.
<br>
Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20403">20403</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="a5f1259d698217673bdf587e52f022961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1259d698217673bdf587e52f022961">&#9670;&nbsp;</a></span>FUNCSEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::FUNCSEL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FUNCSEL
</font><br><p> <font size="2">
Offset: 0x30  UART Function Select Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>FUNCSEL</td><td><div style="word-wrap: break-word;"><b>Function Select
</b><br>
00 = UART function.
<br>
01 = LIN function (Only Available in UART0/UART1 Channel).
<br>
10 = IrDA function.
<br>
11 = RS-485 function.
<br>
Note: In IrDA function mode (FUNCSEL(UART_FUNCSEL[1:0])=10), the first received data is unreliable and it should be skipped if IrDA receiver is enabled (TXEN(UART_IRDA[1])=0) at the first time.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20409">20409</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="a0cf055aeb3159102df9c35e5fc62359c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf055aeb3159102df9c35e5fc62359c">&#9670;&nbsp;</a></span>INTEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::INTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTEN
</font><br><p> <font size="2">
Offset: 0x04  UART Interrupt Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RDAIEN</td><td><div style="word-wrap: break-word;"><b>Receive Data Available Interrupt Enable Bit
</b><br>
0 = Receive data available interrupt Disabled.
<br>
1 = Receive data available interrupt Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>THREIEN</td><td><div style="word-wrap: break-word;"><b>Transmit Holding Register Empty Interrupt Enable Bit
</b><br>
0 = Transmit holding register empty interrupt Disabled.
<br>
1 = Transmit holding register empty interrupt Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>RLSIEN</td><td><div style="word-wrap: break-word;"><b>Receive Line Status Interrupt Enable Bit
</b><br>
0 = Receive Line Status interrupt Disabled.
<br>
1 = Receive Line Status interrupt Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>MODEMIEN</td><td><div style="word-wrap: break-word;"><b>Modem Status Interrupt Enable Bit
</b><br>
0 = Modem status interrupt Disabled.
<br>
1 = Modem status interrupt Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>RXTOIEN</td><td><div style="word-wrap: break-word;"><b>RX Time-Out Interrupt Enable Bit
</b><br>
0 = RX time-out interrupt Disabled.
<br>
1 = RX time-out interrupt Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>BUFERRIEN</td><td><div style="word-wrap: break-word;"><b>Buffer Error Interrupt Enable Bit
</b><br>
0 = Buffer error interrupt Disabled.
<br>
1 = Buffer error interrupt Enabled.
<br>
</div></td></tr><tr><td>
[8]</td><td>LINIEN</td><td><div style="word-wrap: break-word;"><b>LIN Bus Interrupt Enable Bit (Not Available In UART2/UART3)
</b><br>
0 = LIN bus interrupt Disabled.
<br>
1 = LIN bus interrupt Enabled.
<br>
Note: This bit is used for LIN function mode.
<br>
</div></td></tr><tr><td>
[9]</td><td>WKCTSIEN</td><td><div style="word-wrap: break-word;"><b>nCTS Wake-Up Interrupt Enable Bit
</b><br>
0 = nCTS wake-up system function Disabled.
<br>
1 = Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode.
<br>
</div></td></tr><tr><td>
[10]</td><td>WKDATIEN</td><td><div style="word-wrap: break-word;"><b>Incoming Data Wake-Up Interrupt Enable Bit
</b><br>
0 = Incoming data wake-up system function Disabled.
<br>
1 = Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode.
<br>
Note: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable
<br>
</div></td></tr><tr><td>
[11]</td><td>TOCNTEN</td><td><div style="word-wrap: break-word;"><b>Time-Out Counter Enable Bit
</b><br>
0 = Time-out counter Disabled.
<br>
1 = Time-out counter Enabled.
<br>
</div></td></tr><tr><td>
[12]</td><td>ATORTSEN</td><td><div style="word-wrap: break-word;"><b>nRTS Auto-Flow Control Enable Bit
</b><br>
0 = nRTS auto-flow control Disabled.
<br>
1 = nRTS auto-flow control Enabled.
<br>
Note: When nRTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_FIFO[19:16]), the UART will de-assert nRTS signal.
<br>
</div></td></tr><tr><td>
[13]</td><td>ATOCTSEN</td><td><div style="word-wrap: break-word;"><b>nCTS Auto-Flow Control Enable Bit
</b><br>
0 = nCTS auto-flow control Disabled.
<br>
1 = nCTS auto-flow control Enabled.
<br>
Note: When nCTS auto-flow is enabled, the UART will send data to external device if nCTS input assert (UART will not send data to device until nCTS is asserted).
<br>
</div></td></tr><tr><td>
[14]</td><td>TXPDMAEN</td><td><div style="word-wrap: break-word;"><b>TX DMA Enable Bit
</b><br>
This bit can enable or disable TX DMA service.
<br>
0 = TX DMA Disabled.
<br>
1 = TX DMA Enabled.
<br>
</div></td></tr><tr><td>
[15]</td><td>RXPDMAEN</td><td><div style="word-wrap: break-word;"><b>RX DMA Enable Bit
</b><br>
This bit can enable or disable RX DMA service.
<br>
0 = RX DMA Disabled.
<br>
1 = RX DMA Enabled.
<br>
</div></td></tr><tr><td>
[18]</td><td>ABRIEN</td><td><div style="word-wrap: break-word;"><b>Auto-Baud Rate Interrupt Enable Bit
</b><br>
0 = Auto-baud rate interrupt Disabled.
<br>
1 = Auto-baud rate interrupt Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20398">20398</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="ada15f66e56e66795932cb68174048260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada15f66e56e66795932cb68174048260">&#9670;&nbsp;</a></span>INTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::INTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTSTS
</font><br><p> <font size="2">
Offset: 0x1C  UART Interrupt Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RDAIF</td><td><div style="word-wrap: break-word;"><b>Receive Data Available Interrupt Flag (Read Only)
</b><br>
When the number of bytes in the RX FIFO equals the RFITL then the RDAIF(UART_INTSTS[0]) will be set.
<br>
If RDAIEN (UART_INTEN [0]) is enabled, the RDA interrupt will be generated.
<br>
0 = No RDA interrupt flag is generated.
<br>
1 = RDA interrupt flag is generated.
<br>
Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UART_FIFO[7:4])).
<br>
</div></td></tr><tr><td>
[1]</td><td>THREIF</td><td><div style="word-wrap: break-word;"><b>Transmit Holding Register Empty Interrupt Flag (Read Only)
</b><br>
This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
<br>
If THREIEN (UART_INTEN[1]) is enabled, the THRE interrupt will be generated.
<br>
0 = No THRE interrupt flag is generated.
<br>
1 = THRE interrupt flag is generated.
<br>
Note: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty).
<br>
</div></td></tr><tr><td>
[2]</td><td>RLSIF</td><td><div style="word-wrap: break-word;"><b>Receive Line Interrupt Flag (Read Only)
</b><br>
This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]), is set).
<br>
If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
<br>
0 = No RLS interrupt flag is generated.
<br>
1 = RLS interrupt flag is generated.
<br>
Note1: In RS-485 function mode, this field is set include receiver detect and received address byte character (bit9 = '1') bit.
<br>
At the same time, the bit of ADDRDETF (UART_FIFOSTS[3]) is also set.
<br>
Note2: This bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
<br>
Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared.
<br>
</div></td></tr><tr><td>
[3]</td><td>MODEMIF</td><td><div style="word-wrap: break-word;"><b>MODEM Interrupt Flag (Read Only) Channel This bit is set when the nCTS pin has state change (CTSDETF (UART_MODEMSTS[0]) = 1). If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
</b><br>
0 = No Modem interrupt flag is generated.
<br>
1 = Modem interrupt flag is generated.
<br>
Note: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF(UART_MODEMSTS[0]).
<br>
</div></td></tr><tr><td>
[4]</td><td>RXTOIF</td><td><div style="word-wrap: break-word;"><b>Time-Out Interrupt Flag (Read Only)
</b><br>
This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
<br>
If TOUTIEN (UART_INTEN [4]) is enabled, the Tout interrupt will be generated.
<br>
0 = No Time-out interrupt flag is generated.
<br>
1 = Time-out interrupt flag is generated.
<br>
Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
<br>
</div></td></tr><tr><td>
[5]</td><td>BUFERRIF</td><td><div style="word-wrap: break-word;"><b>Buffer Error Interrupt Flag (Read Only)
</b><br>
This bit is set when the TX FIFO or RX FIFO overflows (TXOVIF (UART_FIFOSTS[24]) or RXOVIF (UART_FIFOSTS[0]) is set).
<br>
When BERRIF (UART_INTSTS[5])is set, the transfer is not correct.
<br>
If BFERRIEN (UART_INTEN [8]) is enabled, the buffer error interrupt will be generated.
<br>
0 = No buffer error interrupt flag is generated.
<br>
1 = Buffer error interrupt flag is generated.
<br>
Note: This bit is read only.
<br>
This bit is cleared if both of RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]) are cleared to 0 by writing 1 to RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]).
<br>
</div></td></tr><tr><td>
[6]</td><td>WKIF</td><td><div style="word-wrap: break-word;"><b>UART Wake-up Interrupt Flag (Read Only)
</b><br>
This bit is set when DATWKIF (UART_INTSTS[17]) or CTSWKIF(UART_INTSTS[16]) is set to 1.
<br>
0 = No DATWKIF and CTSWKIF are generated.
<br>
1 = DATWKIF or CTSWKIF.
<br>
Note: This bit is read only.
<br>
This bit is cleared if both of DATWKIF (UART_INTSTS[17]) and CTSWKIF(UART_INTSTS[16]) are cleared to 0 by writing 1 to DATWKIF (UART_INTSTS[17]) and CTSWKIF (UART_INTSTS[17]).
<br>
</div></td></tr><tr><td>
[7]</td><td>LINIF</td><td><div style="word-wrap: break-word;"><b>LIN Bus Interrupt Flag (Read Only) (Not Available in UART2/UART3 Channel)
</b><br>
This bit is set when LIN slave header detect (SLVHDETF (UART_LINSTS[0] =1)), LIN break detect (BRKDETF(UART_LINSTS[9])=1), bit error detect (BITEF(UART_LINSTS[9])=1), LIN slave ID parity error (SLVIDPEF(UART_LINSTS[2]) = 1) or LIN slave header error detect (SLVHEF (UART_LINSTS[1])).
<br>
If LIN_ IEN (UART_INTEN [8]) is enabled the LIN interrupt will be generated.
<br>
0 = None of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
<br>
1 = At least one of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
<br>
Note: This bit is read only.
<br>
This bit is cleared when SLVHDETF(UART_LINSTS[0]), BRKDETF(UART_LINSTS[8]), BITEF(UART_LINSTS[9]), SLVIDPEF (UART_LINSTS[2]), SLVHEF(UART_LINSTS[1]) and SLVSYNCF(UART_LINSTS[3]) all are cleared.
<br>
</div></td></tr><tr><td>
[8]</td><td>RDAINT</td><td><div style="word-wrap: break-word;"><b>Receive Data Available Interrupt Indicator (Read Only)
</b><br>
This bit is set if RDAIEN (UART_INTEN[0]) and RDAIF (UART_INTSTS[0]) are both set to 1.
<br>
0 = No RDA interrupt is generated.
<br>
1 = RDA interrupt is generated.
<br>
</div></td></tr><tr><td>
[9]</td><td>THREINT</td><td><div style="word-wrap: break-word;"><b>Transmit Holding Register Empty Interrupt Indicator (Read Only)
</b><br>
This bit is set if THREIEN (UART_INTEN[1])and THREIF(UART_INTSTS[1]) are both set to 1.
<br>
0 = No DATE interrupt is generated.
<br>
1 = DATE interrupt is generated.
<br>
</div></td></tr><tr><td>
[10]</td><td>RLSINT</td><td><div style="word-wrap: break-word;"><b>Receive Line Status Interrupt Indicator (Read Only)
</b><br>
This bit is set if RLSIEN (UART_INTEN[2]) and RLSIF(UART_INTSTS[2]) are both set to 1.
<br>
0 = No RLS interrupt is generated.
<br>
1 = RLS interrupt is generated.
<br>
</div></td></tr><tr><td>
[11]</td><td>MODEMINT</td><td><div style="word-wrap: break-word;"><b>MODEM Status Interrupt Indicator (Read Only)
</b><br>
This bit is set if MODEMIEN(UART_INTEN[3]) and MODEMIF(UART_INTSTS[4]) are both set to 1
<br>
0 = No Modem interrupt is generated.
<br>
1 = Modem interrupt is generated.
<br>
</div></td></tr><tr><td>
[12]</td><td>RXTOINT</td><td><div style="word-wrap: break-word;"><b>Time-Out Interrupt Indicator (Read Only)
</b><br>
This bit is set if TOUTIEN(UART_INTEN[4]) and RXTOIF(UART_INTSTS[4]) are both set to 1.
<br>
0 = No Tout interrupt is generated.
<br>
1 = Tout interrupt is generated.
<br>
</div></td></tr><tr><td>
[13]</td><td>BUFERRINT</td><td><div style="word-wrap: break-word;"><b>Buffer Error Interrupt Indicator (Read Only)
</b><br>
This bit is set if BFERRIEN(UART_INTEN[5]) and BERRIF(UART_INTSTS[5]) are both set to 1.
<br>
0 = No buffer error interrupt is generated.
<br>
1 = Buffer error interrupt is generated.
<br>
</div></td></tr><tr><td>
[15]</td><td>LININT</td><td><div style="word-wrap: break-word;"><b>LIN Bus Interrupt Indicator (Read Only)(Not Available in UART2/UART3 Channel)
</b><br>
This bit is set if LINIEN (UART_INTEN[8]) and LIN IF(UART_INTSTS[7]) are both set to 1.
<br>
0 = No LIN Bus interrupt is generated.
<br>
1 = The LIN Bus interrupt is generated.
<br>
</div></td></tr><tr><td>
[16]</td><td>CTSWKIF</td><td><div style="word-wrap: break-word;"><b>nCTS Wake-Up Interrupt Flag (Read Only)
</b><br>
0 = Chip stays in power-down state.
<br>
1 = Chip wake-up from power-down state by nCTS wake-up.
<br>
Note1: If WKCTSIEN (UART_INTEN[9])is enabled, the wake-up interrupt is generated.
<br>
Note2: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[17]</td><td>DATWKIF</td><td><div style="word-wrap: break-word;"><b>Data Wake-Up Interrupt Flag (Read Only)
</b><br>
This bit is set if chip wake-up from power-down state by data wake-up.
<br>
0 = Chip stays in power-down state.
<br>
1 = Chip wake-up from power-down state by data wake-up.
<br>
Note1: If WKDATIEN (UART_INTEN[10]) is enabled, the wake-up interrupt is generated.
<br>
Note2: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[18]</td><td>HWRLSIF</td><td><div style="word-wrap: break-word;"><b>In DMA Mode, Receive Line Status Flag (Read Only)
</b><br>
This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UART_FIFOSTS[6]), FEF (UART_FIFOSTS[5]) and PEF (UART_FIFOSTS[4]) is set).
<br>
If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
<br>
0 = No RLS interrupt flag is generated.
<br>
1 = RLS interrupt flag is generated.
<br>
Note1: In RS-485 function mode, this field include receiver detect any address byte received address byte character (bit9 = '1') bit.
<br>
Note2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
<br>
Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared
<br>
</div></td></tr><tr><td>
[19]</td><td>HWMODIF</td><td><div style="word-wrap: break-word;"><b>In DMA Mode, MODEM Interrupt Flag (Read Only)
</b><br>
This bit is set when the nCTS pin has state change (CTSDETF (UART_CTSDETF[0] =1)).
<br>
If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
<br>
0 = No Modem interrupt flag is generated.
<br>
1 = Modem interrupt flag is generated.
<br>
Note: This bit is read only and reset to 0 when the bit UART_CTSDETF (US_MSR[0]) is cleared by writing 1 on CTSDETF (UART_CTSDETF [0]).
<br>
</div></td></tr><tr><td>
[20]</td><td>HWTOIF</td><td><div style="word-wrap: break-word;"><b>In DMA Mode, Time-Out Interrupt Flag (Read Only)
</b><br>
This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UART_TOUT[7:0]).
<br>
If TOUTIEN (UART_INTEN [4]) is enabled, the Tout interrupt will be generated.
<br>
0 = No Time-out interrupt flag is generated.
<br>
1 = Time-out interrupt flag is generated.
<br>
Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
<br>
</div></td></tr><tr><td>
[21]</td><td>HWBUFEIF</td><td><div style="word-wrap: break-word;"><b>In DMA Mode, Buffer Error Interrupt Flag (Read Only)
</b><br>
This bit is set when the TX or RX FIFO overflows (TXOVIF (UART_FIFOSTS [24]) or RXOVIF (UART_FIFOSTS[0]) is set).
<br>
When BERRIF (UART_INTSTS[5]) is set, the transfer maybe is not correct.
<br>
If BFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.
<br>
0 = No buffer error interrupt flag is generated.
<br>
1 = Buffer error interrupt flag is generated.
<br>
Note: This bit is cleared when both TXOVIF (UART_FIFOSTS[24]]) and RXOVIF (UART_FIFOSTS[0]) are cleared.
<br>
</div></td></tr><tr><td>
[26]</td><td>HWRLSINT</td><td><div style="word-wrap: break-word;"><b>In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)
</b><br>
This bit is set if RLSIEN (UART_INTEN[2])and HWRLSIF(UART_INTSTS[18]) are both set to 1.
<br>
0 = No RLS interrupt is generated in DMA mode.
<br>
1 = RLS interrupt is generated in DMA mode.
<br>
</div></td></tr><tr><td>
[27]</td><td>HWMODINT</td><td><div style="word-wrap: break-word;"><b>In DMA Mode, MODEM Status Interrupt Indicator (Read Only)
</b><br>
This bit is set if MODEMIEN(UART_INTEN[3]) and HWMODIF(UART_INTSTS[3]) are both set to 1.
<br>
0 = No Modem interrupt is generated in DMA mode.
<br>
1 = Modem interrupt is generated in DMA mode.
<br>
</div></td></tr><tr><td>
[28]</td><td>HWTOINT</td><td><div style="word-wrap: break-word;"><b>In DMA Mode, Time-Out Interrupt Indicator (Read Only)
</b><br>
This bit is set if TOUTIEN (UART_INTEN[4])and HWTOIF(UART_INTSTS[20]) are both set to 1.
<br>
0 = No Tout interrupt is generated in DMA mode.
<br>
1 = Tout interrupt is generated in DMA mode.
<br>
</div></td></tr><tr><td>
[29]</td><td>HWBUFEINT</td><td><div style="word-wrap: break-word;"><b>In DMA Mode, Buffer Error Interrupt Indicator (Read Only)
</b><br>
This bit is set if BFERRIEN (UART_INTEN[5]) and HWBEIF (UART_INTSTS[5])are both set to 1.
<br>
0 = No buffer error interrupt is generated in DMA mode.
<br>
1 = Buffer error interrupt is generated in DMA mode.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20404">20404</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="ac01ae1a9bbaa02f54a6e7cc944450b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01ae1a9bbaa02f54a6e7cc944450b62">&#9670;&nbsp;</a></span>IRDA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::IRDA</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRDA
</font><br><p> <font size="2">
Offset: 0x28  UART IrDA Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>TXEN</td><td><div style="word-wrap: break-word;"><b>IrDA Receiver/Transmitter Selection Enable Bit
</b><br>
0 = IrDA Transmitter Disabled and Receiver Enabled. (Default)
<br>
1 = IrDA Transmitter Enabled and Receiver Disabled.
<br>
Note: In IrDA function mode (FUNCSEL(UART_FUNCSEL[1:0])=10), the first received data is unreliable and it should be skipped if IrDA receiver is enabled (TXEN(UART_IRDA[1])=0) at the first time.
<br>
</div></td></tr><tr><td>
[5]</td><td>TXINV</td><td><div style="word-wrap: break-word;"><b>IrDA Inverse Transmitting Output Signal
</b><br>
0 = None inverse transmitting signal. (Default)
<br>
1 = Inverse transmitting output signal.
<br>
</div></td></tr><tr><td>
[6]</td><td>RXINV</td><td><div style="word-wrap: break-word;"><b>IrDA Inverse Receive Input Signal
</b><br>
0 = None inverse receiving input signal.
<br>
1 = Inverse receiving input signal. (Default)
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20407">20407</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="afabb58cc2e95cfafa6b62518953d37aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabb58cc2e95cfafa6b62518953d37aa">&#9670;&nbsp;</a></span>LINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::LINE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">LINE
</font><br><p> <font size="2">
Offset: 0x0C  UART Line Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>WLS</td><td><div style="word-wrap: break-word;"><b>Word Length Selection
</b><br>
This field sets UART word length.
<br>
00 = 5 bits.
<br>
01 = 6 bits.
<br>
10 = 7 bits.
<br>
11 = 8 bits.
<br>
</div></td></tr><tr><td>
[2]</td><td>NSB</td><td><div style="word-wrap: break-word;"><b>Number Of "STOP Bit"
</b><br>
0 = One "STOP bit" is generated in the transmitted data.
<br>
1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
<br>
When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
<br>
</div></td></tr><tr><td>
[3]</td><td>PBE</td><td><div style="word-wrap: break-word;"><b>Parity Bit Enable Bit
</b><br>
0 = No parity bit generated Disabled.
<br>
1 = Parity bit generated Enabled.
<br>
Note : Parity bit is generated on each outgoing character and is checked on each incoming data.
<br>
</div></td></tr><tr><td>
[4]</td><td>EPE</td><td><div style="word-wrap: break-word;"><b>Even Parity Enable Bit
</b><br>
0 = Odd number of logic 1's is transmitted and checked in each word.
<br>
1 = Even number of logic 1's is transmitted and checked in each word.
<br>
Note:This bit has effect only when PBE (UART_LINE[3]) is set.
<br>
</div></td></tr><tr><td>
[5]</td><td>SPE</td><td><div style="word-wrap: break-word;"><b>Stick Parity Enable Bit
</b><br>
0 = Stick parity Disabled.
<br>
1 = Stick parity Enabled.
<br>
Note: If PBE (UART_LINE[3]) and EPE (UART_LINE[4]) are logic 1, the parity bit is transmitted and checked as logic 0.
<br>
If PBE (UART_LINE[3]) is 1 and EPE (UART_LINE[4]) is 0 then the parity bit is transmitted and checked as 1.
<br>
</div></td></tr><tr><td>
[6]</td><td>BCB</td><td><div style="word-wrap: break-word;"><b>Break Control Bit
</b><br>
0 = Break Control Disabled.
<br>
1 = Break Control Enabled.
<br>
Note: When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
<br>
This bit acts only on TX line and has no effect on the transmitter logic.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20400">20400</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="aa38873ff3f8930d902c756500ec1eb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38873ff3f8930d902c756500ec1eb4a">&#9670;&nbsp;</a></span>MODEM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::MODEM</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MODEM
</font><br><p> <font size="2">
Offset: 0x10  UART Modem Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>RTS</td><td><div style="word-wrap: break-word;"><b>nRTS (Request-To-Send) Signal Control
</b><br>
This bit is direct control internal nRTS signal active or not, and then drive the nRTS pin output with RTSACTLV bit configuration.
<br>
0 = nRTS signal is active.
<br>
1 = nRTS signal is inactive.
<br>
Note1: This nRTS signal control bit is not effective when nRTS auto-flow control is enabled in UART function mode.
<br>
Note2: This nRTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
<br>
</div></td></tr><tr><td>
[9]</td><td>RTSACTLV</td><td><div style="word-wrap: break-word;"><b>nRTS Pin Active Level
</b><br>
This bit defines the active level state of nRTS pin output.
<br>
0 =n RTS pin output is high level active.
<br>
1 = nRTS pin output is low level active. (Default)
<br>
Note1: Refer to Figure 6.21-10 and Figure 6.21-11 for UART function mode.
<br>
Note2: Refer to Figure 6.21-21 and Figure 6.21-22 for RS-485 function mode.
<br>
</div></td></tr><tr><td>
[13]</td><td>RTSSTS</td><td><div style="word-wrap: break-word;"><b>nRTS Pin Status (Read Only)
</b><br>
This bit mirror from nRTS pin output of voltage logic status.
<br>
0 = nRTS pin output is low level voltage logic state.
<br>
1 = nRTS pin output is high level voltage logic state.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20401">20401</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="aa690036996b10aec30c30f25f68692e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa690036996b10aec30c30f25f68692e6">&#9670;&nbsp;</a></span>MODEMSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::MODEMSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MODEMSTS
</font><br><p> <font size="2">
Offset: 0x14  UART Modem Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CTSDETF</td><td><div style="word-wrap: break-word;"><b>Detect nCTS State Change Flag (Read Only)
</b><br>
This bit is set whenever nCTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN [3]) is set to 1.
<br>
0 = nCTS input has not change state.
<br>
1 = nCTS input has change state.
<br>
Note: This bit is read only, but can be cleared by writing "1" to it.
<br>
</div></td></tr><tr><td>
[4]</td><td>CTSSTS</td><td><div style="word-wrap: break-word;"><b>nCTS Pin Status (Read Only)
</b><br>
This bit mirror from nCTS pin input of voltage logic status.
<br>
0 = nCTS pin input is low level voltage logic state.
<br>
1 = nCTS pin input is high level voltage logic state.
<br>
Note: This bit echoes when UART Controller peripheral clock is enabled, and nCTS multi-function port is selected.
<br>
</div></td></tr><tr><td>
[8]</td><td>CTSACTLV</td><td><div style="word-wrap: break-word;"><b>nCTS Pin Active Level
</b><br>
This bit defines the active level state of nCTS pin input.
<br>
0 = nCTS pin input is high level active.
<br>
1 = nCTS pin input is low level active. (Default)
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20402">20402</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<a id="abccaf08eb25ede5ba592d720ef865d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccaf08eb25ede5ba592d720ef865d93">&#9670;&nbsp;</a></span>TOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::TOUT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TOUT
</font><br><p> <font size="2">
Offset: 0x20  UART Time-out Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>TOIC</td><td><div style="word-wrap: break-word;"><b>Time-Out Interrupt Comparator
</b><br>
The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.
<br>
Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UART_TOUT[7:0])), a receiver time-out interrupt (RXTOINT(UART_INTSTS[12])) is generated if RXTOIEN (UART_INTEN [4]) enabled.
<br>
A new incoming data word or RX FIFO empty will clear RXTOINT(UART_INTSTS[12]).
<br>
In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255.
<br>
So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
<br>
</div></td></tr><tr><td>
[15:8]</td><td>DLY</td><td><div style="word-wrap: break-word;"><b>TX Delay Time Value
</b><br>
This field is used to programming the transfer delay time between the last stop bit and next start bit.
<br>
The unit is bit time.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_m4521_8h_source.html#l20405">20405</a> of file <a class="el" href="_m4521_8h_source.html">M4521.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Device/Nuvoton/M4521/Include/<a class="el" href="_m4521_8h_source.html">M4521.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 6 2019 09:14:01 for M4521 BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
